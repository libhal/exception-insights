import os
import queue
import subprocess
import re
from typing import Iterator


class Node:
    def __init__(self, nid: int, func_name: str, *, 
                 demangled_name: str = None, 
                 visibility: str = None, 
                 availability: str = None, 
                 flags: str = None, **kwargs) -> None: # kwargs is hack to accept extra uneeded params because lazy
        self.callees: list[Node] = []
        self.callers: list[Node] = []
        self.nid = nid
        self.visablity = visibility
        self.availability = availability
        self.flags = flags
        self.func_name = func_name
        self.demangled_name = demangled_name
    
    def __hash__(self) -> int:
        return hash(self.func_name)
    
    def __str__(self) -> str:
        return f"""
        name: {self.func_name}
        demangled name: {self.demangled_name}
        id: {self.nid}
        callees: {[n.func_name for n in self.callees]}
        callers: {[n.func_name for n in self.callers]}
        """.strip()


def parse_file(file_path: str, print_result = False) -> Node:
    """
    Parse a .whole-program file generated by GCC's -fdump-ipa-whole-program flag (use -flto for multi-TU dump).
    Returns root node of graph (main)
    """
    # Verify file path is valid and that the file to parse is a whole-program file
    file_name = file_path.split('/')[-1]
    if not os.path.exists(file_path) or file_name.split(".")[-1].lower() != "whole-program":
        raise AttributeError("Unknown path or not a wpa dump")

    raw_entry_strings: list[str] = []
    nodes: dict[str, Node] = {}
    with open(file_path) as f:
        # parse out metadata prior to symbol table
        for line in f:
            if line.strip() == "Symbol table:":
                break

        # Parse each table entry
        cur_raw = ""
        in_current_entry = False
        is_function = True
        for line in f:
            if line.isspace():
                continue
            if not line[0].isspace():
                in_current_entry = False

            if line.strip().startswith("Type") and "function" not in line.strip().split():
                is_function = False
                continue

            if not in_current_entry:
                if is_function:
                    raw_entry_strings.append(cur_raw)
                cur_raw = ""
                is_function = True  # we assume the next entry will be a function
                in_current_entry = True

            cur_raw += line.strip() + "\n"

        else:
            if is_function:
                raw_entry_strings.append(cur_raw)

    # Parse symbol table entries into dicts
    table_entries: list[dict[str, str]] = []
    fn_name_re = re.compile(r".+\/\d+")
    for raw in raw_entry_strings:
        if not raw or raw.isspace():
            continue
        
        d = {}
        for i, entry in enumerate(filter(lambda s: s and not s.isspace(), map(lambda s: s.strip(), raw.split("\n")))):
            if i == 0:
                m = fn_name_re.match(entry)
                fn_name, fn_id_str = m.group(0).split("/")
                d['name'] = fn_name
                d['id'] = int(fn_id_str)
                d['demangled_name'] = entry.split()[-1][1:-1]
                continue

            if ":" not in entry:
                if not d.get("misc_strings"):
                    d["misc_strings"] = [entry]
                else:
                    d["misc_strings"].append(entry)
                continue

            key, val = entry.split(":")
            d[key.strip().replace(" ", "_").lower()] = val.strip()
        table_entries.append(d)

    def parse_fn_list(fn_list_str: str) -> Iterator[str]:
        """
        Helper function that parses stringified list of call[ee/er]s in each entry
        """
        return map(lambda _fn_name: _fn_name.strip().split("/")[0],
               filter(lambda x: fn_name_re.match(x), fn_list_str.split()))
    
    # Create nodes
    for entry in table_entries:
        if not entry['calls'] and not entry['called_by']:
            continue

        n = Node(entry['id'], entry['name'], **entry)
        if n not in nodes:
            nodes[entry['name']] = n
    
    # Create edges
    for entry in table_entries:
        caller_strs = parse_fn_list(entry['called_by'])
        callee_strs = parse_fn_list(entry["calls"])
        if not nodes.get(entry['name']):
            continue
        
        get_node = lambda s: nodes[s]
        n = nodes[entry['name']]
        n.callers = list(map(get_node, caller_strs))
        n.callees = list(map(get_node, callee_strs))

    if print_result:
        print("\n\n".join(map(str, nodes.values())))
    return nodes['main']

def traverse_graph(root: Node):
    """
    BFS for simple traversal
    """
    q: queue.SimpleQueue[Node] = queue.SimpleQueue()
    seen_nodes = list()
    q.put(root)

    def traverse(node: Node, prefix: str, seen: list[Node]) -> str:
        if node is None:
            return "END\n"
        seen.append(node)

        call_chain = prefix + f"{node.func_name} --> "
        if not node.callees:
            return call_chain + "END\n"

        out = ""
        for n in node.callees:
            if n not in seen or not n.callees:
                out += traverse(n, call_chain, seen)

        return out

    print(traverse(root, "", seen_nodes))


root = parse_file(
    "testing_programs/demo_class.wpa.081i.whole-program", True)

print("\n\n\ntraversal:")
traverse_graph(root)