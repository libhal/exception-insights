#pragma once

#include <cctype>
#include <cstddef>
#include <format>
#include <optional>
#include <ranges>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

#include <ctll/fixed_string.hpp>
#include <ctre.hpp>
#include <ctre/wrapper.hpp>

namespace safe {

/**
 * @brief A node representing an entry within a program's callgraph. Used
 * primarily as a data class with publically accessible member variables.
 * Should be used to build an N-tree when building a callgraph. Currently, class
 * is tailored for GCC callgraph dumped artifacts, subject to change.
 */
struct CallGraphNode
{

    /**
     * @brief Get a node from a given function ID dictated by the compiler. Node
     * is acquired from internal hashmap storing all nodes in existance
     *
     * @param p_id The function ID
     *
     * @returns An optional reference to the node if found or nullopt if not
     * found.
     */
    static std::optional<std::reference_wrapper<CallGraphNode>>
    get_node_from_id(size_t p_id)
    {
        try {
            return std::ref(all_nodes.at(p_id));
        } catch (std::out_of_range) {
            return std::nullopt;
        }
    }

    /**
     * @brief Get a node from a function's name.
     * NOTE: Expects the original functions name, not the demangled name.
     *
     * @param p_name - The unmodified, mangled name of the function to look up.
     *
     * @return An optional reference to the node if found or nullopt if not
     * found.
     */
    static std::optional<std::reference_wrapper<CallGraphNode>>
    get_node_from_name(std::string_view p_name)
    {
        // TODO: Make more efficent
        for (auto& [id, n] : all_nodes) {
            if (p_name == n.fn_name) {
                return std::ref(n);
            }
        }

        return std::nullopt;
    }

    CallGraphNode(size_t p_nid,
                  std::string p_fn_name,
                  std::string p_demangled_name,
                  std::string p_visibility,
                  std::string p_avaliablity,
                  std::string p_flags)
      : id(p_nid)
      , fn_name(std::move(p_fn_name))
      , demangled_name(std::move(p_demangled_name))
      , visibility(std::move(p_visibility))
      , availability(std::move(p_avaliablity))
      , flags(std::move(p_flags)){};

    CallGraphNode& operator=(CallGraphNode const&) = default;
    CallGraphNode(CallGraphNode const&) = default;
    CallGraphNode& operator=(CallGraphNode&&) = default;
    CallGraphNode(CallGraphNode&&) = default;

    // TODO: alias
    size_t id;
    std::string fn_name;
    std::string demangled_name;
    std::string visibility;
    std::string availability;
    std::string flags;

    // TODO: Helper function to fetch vector of nodes
    std::vector<std::pair<size_t, std::vector<std::string>>> callees;
    std::vector<std::pair<size_t, std::vector<std::string>>> callers;

    // TODO: Maybe a multi-key hash-map where lookup can be done either with a
    // name or an ID.
    static inline std::unordered_map<size_t, CallGraphNode> all_nodes;
};

/**
 * @brief Parses a GCC generated whole-program file generated by the
 * `-fdump-ipa-whole-program flag.` For a cross translation unit file (wpa
 * instead of cpp), -flto must also be enabled.
 *
 * @param file_path The string of the file path. Can be relative to the binary
 * or an absolute path.
 *
 */
CallGraphNode parse_gcc_wpa(std::string_view file_path);

}  // namespace safe

// template<>
// struct std::formatter<safe::CallGraphNode> : std::formatter<std::string>
// {
//   private:
//     constexpr static auto get_names(
//       std::span<const std::pair<size_t, std::vector<std::string>>> v)
//     {
//         namespace rng = std::ranges;
//         namespace views = rng::views;

//         return v | views::transform([](const auto& p) {
//                    return std::format(
//                      "{}: {}",
//                      safe::CallGraphNode::get_node_from_id(p.first)
//                        .value()
//                        .get()
//                        .fn_name,
//                      p.second);
//                })
//                | rng::to<std::vector<std::string>>();
//     }

//   public:
//     inline auto format(const safe::CallGraphNode& n, format_context& ctx)
//     const
//     {
//         return formatter<std::string>::format(std::format("id: {}\n"
//                                                           "func_name: {}\n"
//                                                           "demangled_name:
//                                                           {}\n" "visibility:
//                                                           {}\n"
//                                                           "availability:
//                                                           {}\n" "flags: {}\n"
//                                                           "callers: {}\n"
//                                                           "callees: {}",
//                                                           n.id,
//                                                           n.fn_name,
//                                                           n.demangled_name,
//                                                           n.visibility,
//                                                           n.availability,
//                                                           n.flags,
//                                                           get_names(n.callers),
//                                                           get_names(n.callees)),
//                                               ctx);
//     }
// };